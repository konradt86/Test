Zgromadziłem wyniki dla wszystkich podgrup w jednym DataFrame, gdzie dla każdego funduszu i każdej wartości `credit_spread_multiple` wypisano pierwszą wartość liczbową (lub '-') dla kolumn RDM. Oto skrypt, który użyłem do stworzenia tego DataFrame:

```python
all_rows = []
for fund, credit_spreads in first_numeric_rdm_by_subgroup.items():
    for credit_spread, rdm_values in credit_spreads.items():
        row = {'FUND': fund, 'Credit Spread': credit_spread}
        row.update({rdm_col: rdm_values[i] for i, rdm_col in enumerate(rdm_columns)})
        all_rows.append(row)

all_results_df = pd.DataFrame(all_rows)
```

Powyżej pokazane są pierwsze kilka wierszy wynikowego DataFrame jako przykład. Każdy wiersz reprezentuje unikalną kombinację funduszu i `credit_spread_multiple`, z odpowiednimi wartościami dla kolumn RDM.

Oto skrypt, który iteruje przez wszystkie podgrupy i wybiera pierwszą wartość liczbową z każdej kolumny RDM. Jeżeli nie ma wartości liczbowej, wstawia "-":

```python
first_numeric_rdm_by_subgroup = {}

for fund, credit_spreads in subgroups_by_fund_credit_spread.items():
    first_numeric_rdm_by_subgroup[fund] = {}
    for credit_spread, subgroup in credit_spreads.items():
        first_numeric_rdm_by_subgroup[fund][credit_spread] = []
        for rdm_col in rdm_columns:
            # Extract the first numeric value for the RDM column
            first_numeric_value = subgroup[rdm_col].apply(lambda x: x if isinstance(x, (int, float)) else None).dropna().head(1)
            first_numeric_rdm_by_subgroup[fund][credit_spread].append(first_numeric_value.iloc[0] if not first_numeric_value.empty else '-')

# Wynik jest słownikiem słowników, gdzie pierwszy klucz to fundusz, drugi to wartość credit_spread_multiple,
# a wartości to listy pierwszych wartości liczbowych lub '-' dla kolumn RDM.
```

Ten skrypt gromadzi dane w strukturze, która pozwala na ł
